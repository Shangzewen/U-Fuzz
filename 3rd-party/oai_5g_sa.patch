diff --git a/cmake_targets/CMakeLists.txt b/cmake_targets/CMakeLists.txt
index b1f5fb5..f865015 100644
--- a/cmake_targets/CMakeLists.txt
+++ b/cmake_targets/CMakeLists.txt
@@ -2738,6 +2738,7 @@ if (${T_TRACER})
   set(T_SOURCE
       ${OPENAIR_DIR}/common/utils/T/T_IDs.h
       ${OPENAIR_DIR}/common/utils/T/T.c
+      ${OPENAIR_DIR}/common/utils/T/shared_memory.c
       ${OPENAIR_DIR}/common/utils/T/local_tracer.c)
   set(T_LIB "rt")
 endif (${T_TRACER})
@@ -3070,6 +3071,10 @@ add_executable(nr-uesoftmodem
   ${SHLIB_LOADER_SOURCES}
   )
 
+# FUZZ-NR: duplication #
+target_include_directories(nr-softmodem PUBLIC /usr/local/include/json-c)
+# ---------------------- #
+
 target_link_libraries (nr-uesoftmodem
   -Wl,--start-group
   RRC_LIB NR_RRC_LIB NGAP_LIB NGAP_GNB SECU_CN SECU_OSA UTIL HASHTABLE SCTP_CLIENT UDP SCHED_RU_LIB SCHED_UE_LIB SCHED_NR_UE_LIB
@@ -3083,6 +3088,10 @@ target_link_libraries (nr-uesoftmodem pthread m ${CONFIG_LIB} rt crypt ${CRYPTO_
 target_link_libraries (nr-uesoftmodem ${LIB_LMS_LIBRARIES})
 target_link_libraries (nr-uesoftmodem ${T_LIB})
 
+# FUZZ-NR: duplication #
+target_link_libraries (nr-softmodem czmq json-c)
+# ---------------------- #
+
 add_dependencies( nr-uesoftmodem ldpc_orig ldpc_optim ldpc_optim8seg ldpc )
 
 ###################################"
diff --git a/common/utils/T/shared_memory.c b/common/utils/T/shared_memory.c
new file mode 100644
index 0000000..c6665ec
--- /dev/null
+++ b/common/utils/T/shared_memory.c
@@ -0,0 +1,419 @@
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/ipc.h>
+#include <sys/time.h>
+#include <time.h>
+#include <assert.h>
+#include <errno.h>
+#include <unistd.h>
+#define __USE_GNU
+#include <pthread.h>
+#include <sched.h>
+#include "shared_memory.h"
+
+uint32_t MAX_WAIT_TIME = 2;
+struct Sync local_sync;
+struct Arguments local_args;
+uint8_t is_server = 0;
+
+void cleanup(struct Sync *sync)
+{
+    // Detach the shared memory from this process' address space.
+    // If this is the last process using this shared memory, it is removed.
+    shmdt((void *)sync->raw_shared_memory);
+
+    /*
+        Deallocate manually for security. We pass:
+            1. The shared memory ID returned by shmget.
+            2. The IPC_RMID flag to schedule removal/deallocation
+                 of the shared memory.
+            3. NULL to the last struct parameter, as it is not relevant
+                 for deletion (it is populated with certain fields for other
+                 calls, notably IPC_STAT, where you would pass a struct shmid_ds*).
+    */
+    shmctl(sync->segment_id, IPC_RMID, NULL);
+    if (sync->mutex_created)
+    {
+        destroy_sync(sync);
+    }
+}
+
+void init_sync(struct Sync *sync)
+{
+    for (size_t i = 0; i < MAX_MUTEXES; i++)
+    {
+        // These structures are used to initialize mutexes
+        // and condition variables. We will use them to set
+        // the PTHREAD_PROCESS_SHARED attribute, which enables
+        // more than one process (and any thread in any of those
+        // processes) to access the mutex and condition variable.
+        pthread_mutexattr_t mutex_attributes;
+        pthread_condattr_t condition_attributes;
+
+        // These methods initialize the attribute structures
+        // with default values so that we must only change
+        // the one we are interested in.
+        if (pthread_mutexattr_init(&mutex_attributes) != 0)
+        {
+            throw_custom("Error initializing mutex attributes");
+        }
+        if (pthread_condattr_init(&condition_attributes) != 0)
+        {
+            throw_custom("Error initializing condition variable attributes");
+        }
+
+        // Here we set the "process-shared"-attribute of the mutex
+        // and condition variable to PTHREAD_PROCESS_SHARED. This
+        // means multiple processes may access these objects. If
+        // we wouldn't do this, the attribute would be PTHREAD_PROCESS
+        // _PRIVATE, where only threads created by the process who
+        // initialized the objects would be allowed to access them.
+        // By passing PTHREAD_PROCESS_SHARED the objects may also live
+        // longer than the process creating them.
+        // clang-format off
+    if (pthread_mutexattr_setpshared(
+                &mutex_attributes, PTHREAD_PROCESS_SHARED) != 0) {
+        throw_custom("Error setting process-shared attribute for mutex");
+    }
+
+    if (pthread_condattr_setpshared(
+                &condition_attributes, PTHREAD_PROCESS_SHARED) != 0) {
+        throw_custom("Error setting process-shared attribute for condition variable");
+    }
+        // clang-format on
+
+        // Initialize the mutex and condition variable and pass the attributes
+        if (pthread_mutex_init(&sync->server_mutex[i]->mutex, &mutex_attributes) != 0)
+        {
+            throw_custom("Error initializing mutex");
+        }
+        if (pthread_cond_init(&sync->server_mutex[i]->condition, &condition_attributes) != 0)
+        {
+            throw_custom("Error initializing condition variable");
+        }
+
+        if (pthread_mutex_init(&sync->client_mutex[i]->mutex, &mutex_attributes) != 0)
+        {
+            throw_custom("Error initializing mutex");
+        }
+        if (pthread_cond_init(&sync->client_mutex[i]->condition, &condition_attributes) != 0)
+        {
+            throw_custom("Error initializing condition variable");
+        }
+
+        // Destroy the attribute objects
+        if (pthread_mutexattr_destroy(&mutex_attributes))
+        {
+            throw_custom("Error destroying mutex attributes");
+        }
+        if (pthread_condattr_destroy(&condition_attributes))
+        {
+            throw_custom("Error destroying condition variable attributes");
+        }
+
+        sync->server_mutex[i]->count = 0;
+        sync->client_mutex[i]->count = 0;
+    }
+}
+
+void destroy_sync(struct Sync *sync)
+{
+    for (size_t i = 0; i < MAX_MUTEXES; i++)
+    {
+        if (pthread_mutex_destroy(&sync->server_mutex[i]->mutex))
+        {
+            throw_custom("Error destroying mutex");
+        }
+        if (pthread_cond_destroy(&sync->server_mutex[i]->condition))
+        {
+            throw_custom("Error destroying condition variable");
+        }
+        if (pthread_mutex_destroy(&sync->client_mutex[i]->mutex))
+        {
+            throw_custom("Error destroying mutex");
+        }
+        if (pthread_cond_destroy(&sync->client_mutex[i]->condition))
+        {
+            throw_custom("Error destroying condition variable");
+        }
+    }
+}
+
+uint8_t sync_wait(struct Mutex *sync)
+{
+    uint8_t status = 1;
+    // Lock the mutex
+    if (pthread_mutex_lock(&sync->mutex) != 0)
+    {
+        throw_custom("Error locking mutex");
+        status = 0;
+    }
+
+    // Move into waiting for the condition variable to be signalled.
+    // For this, it is essential that the mutex first be locked (above)
+    // to avoid data races on the condition variable (e.g. the signal
+    // being sent before the waiting process has begun). In fact, behaviour
+    // is undefined otherwise. Once the mutex has begun waiting, the mutex
+    // is unlocked so that other threads may do something and eventually
+    // signal the condition variable. At that point, this thread wakes up
+    // and *re-acquires* the lock immediately. As such, when this method
+    // returns the lock will be owned by the calling thread.
+    while (sync->count == 0)
+    {
+        struct timespec max_wait;
+        clock_gettime(CLOCK_REALTIME, &max_wait);
+        max_wait.tv_sec += MAX_WAIT_TIME;
+        if (pthread_cond_timedwait(&sync->condition, &sync->mutex, &max_wait) != 0)
+        {
+            puts("[SHM] Timeout waiting for sync");
+            status = 0;
+        }
+    }
+    sync->count=0;
+    if (pthread_mutex_unlock(&sync->mutex) != 0)
+    {
+        throw_custom("Error unlocking mutex");
+        status = 0;
+    }
+
+    return status;
+}
+
+void sync_notify(struct Mutex *sync)
+{
+    if (pthread_mutex_lock(&sync->mutex) != 0)
+    {
+        throw_custom("Error locking mutex");
+    }
+    // Signals to a single thread waiting on the condition variable
+    // to wake up, if any such thread exists. An alternative would be
+    // to call pthread_cond_broadcast, in which case *all* waiting
+    // threads would be woken up.
+    if (sync->count == 0)
+    {
+        if (pthread_cond_signal(&sync->condition) != 0)
+        {
+            throw_custom("Error signalling condition variable");
+        }
+    }
+    sync->count=1;
+    if (pthread_mutex_unlock(&sync->mutex) != 0)
+    {
+        throw_custom("Error unlocking mutex");
+    }
+}
+
+void create_sync(struct Sync *sync, struct Arguments *args)
+{
+func_create_sync:
+    memset(sync, 0, sizeof(struct Sync));
+
+    // The identifier for the shared memory segment
+
+    // Key for the memory segment
+    key_t segment_key = generate_key(SEGMENT_KEY_STR);
+
+    // The size for the segment
+    uint32_t raw_size = (args->size * MAX_MUTEXES) + (sizeof(struct Mutex) * MAX_MUTEXES);
+    uint32_t page_size = ((raw_size / 4096) + 1) * 4096;
+
+    /*
+        The call that actually allocates the shared memory segment.
+        Arguments:
+            1. The shared memory key. This must be unique across the OS.
+            2. The number of bytes to allocate. This will be rounded up to the OS'
+                 pages size for alignment purposes.
+            3. The creation flags and permission bits, where:
+                 - IPC_CREAT means that a new segment is to be created
+                 - IPC_EXCL means that the call will fail if
+                     the segment-key is already taken (removed)
+                 - 0666 means read + write permission for user, group and world.
+        When the shared memory key already exists, this call will fail. To see
+        which keys are currently in use, and to remove a certain segment, you
+        can use the following shell commands:
+            - Use `ipcs -m` to show shared memory segments and their IDs
+            - Use `ipcrm -m <segment_id>` to remove/deallocate a shared memory segment
+    */
+
+    sync->segment_id = shmget(segment_key, page_size, IPC_CREAT | IPC_EXCL | 0666);
+    if (errno == EEXIST)
+    {
+        printf("[SHM] SHM exists\n");
+        sync->segment_id = shmget(segment_key, page_size, 0666);
+
+        if (sync->segment_id < 0)
+        {
+            printf("[SHM] SHM segment size mismatch for ID: %d\n", sync->segment_id);
+            sync->segment_id = shmget(segment_key, 0, 0666);
+            if (shmctl(sync->segment_id, IPC_RMID, NULL) < 0)
+            {
+                fprintf(stderr, "[SHM] Remove error for shmid=%d: %s\n", sync->segment_id, strerror(errno));
+                exit(-1);
+            }
+            else
+            {
+                printf("[SHM] Deleted SHM segment ID: %d\n", sync->segment_id);
+                usleep(10000UL);
+                goto func_create_sync;
+            }
+        }
+    }
+    else
+    {
+        sync->mutex_created = 1;
+    }
+
+    if (sync->segment_id < 0)
+    {
+        usleep(1000000UL);
+        perror("[SHM] Error allocating segment, retrying...");
+        goto func_create_sync;
+    }
+
+    /*
+Once the shared memory segment has been created, it must be
+attached to the address space of each process that wishes to
+use it. For this, we pass:
+    1. The segment ID returned by shmget
+    2. A pointer at which to attach the shared memory segment. This
+         address must be page-aligned. If you simply pass NULL, the OS
+         will find a suitable region to attach the segment.
+    3. Flags, such as:
+         - SHM_RND: round the second argument (the address at which to
+             attach) down to a multiple of the page size. If you don't
+             pass this flag but specify a non-null address as second argument
+             you must ensure page-alignment yourself.
+         - SHM_RDONLY: attach for reading only (independent of access bits)
+shmat will return a pointer to the address space at which it attached the
+shared memory. Children processes created with fork() inherit this segment.
+*/
+    sync->raw_shared_memory = (uint8_t *)shmat(sync->segment_id, NULL, 0);
+
+    if (sync->raw_shared_memory < 0)
+    {
+        throw_custom("Could not attach segment");
+    }
+
+    memset(sync->raw_shared_memory, 0, args->size);
+
+    for (size_t i = 0; i < MAX_MUTEXES; i++)
+    {
+        sync->shared_memory[i] = sync->raw_shared_memory + (i * args->size);
+        sync->client_mutex[i] = (struct Mutex *)(sync->raw_shared_memory + (args->size * MAX_MUTEXES)) + (2 * i);
+        sync->server_mutex[i] = (struct Mutex *)(sync->raw_shared_memory + (args->size * MAX_MUTEXES) + sizeof(struct Mutex)) + (2 * i);
+    }
+
+    if (is_server)
+    {
+        init_sync(sync);
+        sync->mutex_created = 1;
+    }
+}
+
+void throw_custom(const char *message)
+{
+    perror(message);
+    exit(EXIT_FAILURE);
+}
+
+void terminate(const char *message)
+{
+    fputs(message, stderr);
+    exit(EXIT_FAILURE);
+}
+
+void print_error(const char *message)
+{
+    fprintf(stderr, "%s\n", message);
+}
+
+void warn(const char *message)
+{
+    fprintf(stderr, "\033[33mWarning\033[0m: %s\n", message);
+}
+
+int generate_key(const char *path)
+{
+    // Generate a random key from the given file path
+    // (inode etc.) plus the arbitrary character
+    return ftok(path, 'X');
+}
+
+void nsleep(int nanoseconds)
+{
+    struct timespec time = {0, nanoseconds};
+    if (nanosleep(&time, NULL) == -1)
+    {
+        throw_custom("Sleep was interrupted");
+    }
+}
+
+int current_milliseconds()
+{
+    struct timeval current_time;
+
+    if (gettimeofday(&current_time, NULL) == -1)
+    {
+        throw_custom("Error getting time");
+    }
+
+    return timeval_to_milliseconds(&current_time);
+}
+
+int timeval_to_milliseconds(const struct timeval *time)
+{
+    int milliseconds;
+
+    assert(time != NULL);
+
+    milliseconds = time->tv_sec * 1000;
+    milliseconds += time->tv_usec / 1000;
+
+    return milliseconds;
+}
+
+void pin_thread(int where)
+{
+    // Doesn't work on OS X right now
+    // int j;
+    // cpu_set_t cpuset;
+    // pthread_t thread;
+    // thread = pthread_self();
+    // CPU_ZERO(&cpuset);
+    // CPU_SET(where, &cpuset);
+    // pthread_setaffinity_np(thread, sizeof(cpu_set_t), &cpuset);
+    // int s = pthread_getaffinity_np(thread, sizeof(cpu_set_t), &cpuset);
+    // if (s != 0) {
+    //  fprintf(stderr, "error: pthread_getaffinity_np");
+    //  exit(-1);
+    // }
+}
+
+void shm_init(uint8_t _is_server, uint32_t shm_size)
+{
+    is_server = _is_server;
+    local_args.size = shm_size;            // Total size of the shared memory (it's not the same as packet size)
+    create_sync(&local_sync, &local_args); // Function comes from shm-_sync-common.c
+}
+
+void shm_timeout(uint16_t timeout)
+{
+    MAX_WAIT_TIME = timeout;
+}
+
+void shm_notify(uint16_t mutex_num)
+{
+    sync_notify((is_server ? local_sync.client_mutex[mutex_num] : local_sync.server_mutex[mutex_num]));
+}
+
+uint8_t shm_wait(uint16_t mutex_num)
+{
+    return sync_wait((is_server ? local_sync.server_mutex[mutex_num] : local_sync.client_mutex[mutex_num]));
+}
+
+void shm_clean()
+{
+    cleanup(&local_sync);
+}
+
diff --git a/common/utils/T/shared_memory.h b/common/utils/T/shared_memory.h
new file mode 100644
index 0000000..904d764
--- /dev/null
+++ b/common/utils/T/shared_memory.h
@@ -0,0 +1,118 @@
+#ifndef SHM_SYNC_COMMON_H
+#define SHM_SYNC_COMMON_H
+
+#include <pthread.h>
+#include <inttypes.h>
+#include <sys/ipc.h>
+#include <sys/shm.h>
+#include <stdbool.h>
+
+#define SHM_CLIENT 0
+#define SHM_SERVER 1
+#define MAX_MUTEXES 3
+#define SEGMENT_KEY_STR "wshm"
+
+typedef struct Arguments
+{
+    int size;
+    int count;
+
+} Arguments;
+
+struct Mutex
+{
+    pthread_mutex_t mutex;
+    pthread_cond_t condition;
+    int count;
+};
+
+struct Sync
+{
+    int segment_id;
+    uint8_t *raw_shared_memory;
+    uint8_t *shared_memory[MAX_MUTEXES];
+    struct Mutex *client_mutex[MAX_MUTEXES];
+    struct Mutex *server_mutex[MAX_MUTEXES];
+    int mutex_created;
+};
+
+extern struct Sync local_sync;
+
+void cleanup(struct Sync *sync);
+
+void init_sync(struct Sync *sync);
+
+void destroy_sync(struct Sync *sync);
+
+uint8_t sync_wait(struct Mutex *sync);
+
+void sync_notify(struct Mutex *sync);
+
+void create_sync(struct Sync *sync, struct Arguments *args);
+
+void shm_timeout(uint16_t timeout);
+
+void shm_init(uint8_t _is_server, uint32_t shm_size);
+
+void shm_notify(uint16_t mutex_num);
+
+uint8_t shm_wait(uint16_t mutex_num);
+
+void shm_clean();
+
+/******************** DEFINITIONS ********************/
+
+struct timeval;
+
+/******************** INTERFACE ********************/
+
+/**
+ * Calls perror() and exits the program.
+ *
+ * Use this function when the error *is* the result of a syscall failure. Then
+ * it will print the specified message along with the implementation defined
+ * error message that is appended in perror(). Do not append a newline.
+ *
+ * \param message The message to print.
+ *
+ * \see terminate()
+ */
+void throw_custom(const char *message) __attribute__((noreturn));
+
+/**
+ * Prints a message to stderr and exits the program.
+ *
+ * Use this function when the error is not the result of a syscall failure. Do
+ * append a newline to the message.
+ *
+ * \param message The message to print.
+ *
+ * \see throw()
+ */
+void terminate(const char *message) __attribute__((noreturn));
+
+/**
+ * Prints a message to stderr.
+ *
+ * param message The message to print.
+ */
+void print_error(const char *message);
+
+/**
+ * Prints "Warning: <message>".
+ *
+ * \param message The warning message.
+ */
+void warn(const char *message);
+
+int generate_key(const char *path);
+
+void nsleep(int nanoseconds);
+
+int current_milliseconds();
+int timeval_to_milliseconds(const struct timeval *time);
+
+void pin_thread(int where);
+
+#endif /* SHM_SYNC_COMMON_H */
+
diff --git a/common/utils/T/tracer/shm_nr_utils.h b/common/utils/T/tracer/shm_nr_utils.h
new file mode 100644
index 0000000..1a18d37
--- /dev/null
+++ b/common/utils/T/tracer/shm_nr_utils.h
@@ -0,0 +1,215 @@
+#pragma once
+#ifndef SHM_NR_UTILS_
+#define SHM_NR_UTILS_
+
+#include "common/utils/T/shared_memory.h"
+
+#define SHM_MUTEX_0 0
+#define SHM_MUTEX_1 1
+
+#define MAC_NR_PAYLOAD_TAG    0x01
+#define MAC_NR_RNTI_TAG       0x02
+#define MAC_NR_UEID_TAG       0x03
+#define MAC_NR_FRAME_SLOT_TAG 0x07
+
+#define NR_FDD_RADIO 1
+#define NR_TDD_RADIO 2
+
+#define NR_DIRECTION_UPLINK   0
+#define NR_DIRECTION_DOWNLINK 1
+
+#define NR_NO_RNTI 0
+#define NR_RA_RNTI 2
+#define NR_C_RNTI  3
+#define NR_SI_RNTI 4
+
+
+#define W_GNB_PHY_MIB         (200)
+#define W_GNB_MAC_UE_DL_SIB   (201)
+#define W_GNB_PHY_INITIATE_RA_PROCEDURE (202)
+#define W_GNB_MAC_UE_DL_RAR_PDU_WITH_DATA (203)
+#define W_GNB_MAC_UE_DL_PDU_WITH_DATA (204)
+#define W_GNB_MAC_UE_UL_PDU_WITH_DATA (205)
+#define W_GNB_PDCP_PLAIN (206)
+#define W_GNB_PDCP_ENC (207)
+
+// --------------------------------- PDCP --------------------------------------
+
+/* Conditional field. This field is mandatory in case of User Plane PDCP PDU.
+   The format is to have the tag, followed by the value (there is no length field,
+   it's implicit from the tag). The allowed values are defined above. */
+
+#define PDCP_NR_SEQNUM_LENGTH_TAG          0x02
+/* 1 byte */
+
+/* Optional fields. Attaching this info should be added if available.
+   The format is to have the tag, followed by the value (there is no length field,
+   it's implicit from the tag) */
+
+#define PDCP_NR_DIRECTION_TAG              0x03
+/* 1 byte */
+
+#define PDCP_NR_BEARER_TYPE_TAG            0x04
+/* 1 byte */
+
+#define PDCP_NR_BEARER_ID_TAG              0x05
+/* 1 byte */
+
+#define PDCP_NR_UEID_TAG                   0x06
+/* 2 bytes, network order */
+
+#define PDCP_NR_ROHC_COMPRESSION_TAG       0x07
+/* 0 byte */
+
+/* N.B. The following ROHC values only have significance if rohc_compression
+   is in use for the current channel */
+
+#define PDCP_NR_ROHC_IP_VERSION_TAG        0x08
+/* 1 byte */
+
+#define PDCP_NR_ROHC_CID_INC_INFO_TAG      0x09
+/* 0 byte */
+
+#define PDCP_NR_ROHC_LARGE_CID_PRES_TAG    0x0A
+/* 0 byte */
+
+#define PDCP_NR_ROHC_MODE_TAG              0x0B
+/* 1 byte */
+
+#define PDCP_NR_ROHC_RND_TAG               0x0C
+/* 0 byte */
+
+#define PDCP_NR_ROHC_UDP_CHECKSUM_PRES_TAG 0x0D
+/* 0 byte */
+
+#define PDCP_NR_ROHC_PROFILE_TAG           0x0E
+/* 2 bytes, network order */
+
+#define PDCP_NR_MACI_PRES_TAG              0x0F
+/* 0 byte */
+
+#define PDCP_NR_SDAP_HEADER_TAG            0x10
+/* 1 byte, bitmask with PDCP_NR_UL_SDAP_HEADER_PRESENT and/or PDCP_NR_DL_SDAP_HEADER_PRESENT */
+
+#define PDCP_NR_CIPHER_DISABLED_TAG        0x11
+/* 0 byte */
+
+/* PDCP PDU. Following this tag comes the actual PDCP PDU (there is no length, the PDU
+   continues until the end of the frame) */
+#define PDCP_NR_PAYLOAD_TAG                0x01
+
+
+
+inline uint16_t send_pdu_data_nr(int event,
+                                 int direction,
+                                 int rnti_type,
+                                 int rnti,
+                                 int frame,
+                                 int slot,
+                                 uint8_t *payload, int payload_size,
+                                 int8_t preamble)
+{
+   uint16_t payload_offset;
+   uint16_t s_idx = 2;
+   uint8_t *shm_buffer_ptr = local_sync.shared_memory[SHM_MUTEX_0];
+
+   shm_buffer_ptr[s_idx++] = event;
+   // Wireshark payload starts here
+   shm_buffer_ptr[s_idx++] = NR_TDD_RADIO;
+   shm_buffer_ptr[s_idx++] = direction;
+   shm_buffer_ptr[s_idx++] = rnti_type;
+   if (rnti_type == NR_C_RNTI || rnti_type == NR_RA_RNTI)
+   {
+      shm_buffer_ptr[s_idx++] = MAC_NR_RNTI_TAG;
+      shm_buffer_ptr[s_idx++] = (rnti >> 8) & 0xFF;
+      shm_buffer_ptr[s_idx++] = rnti & 0xFF;
+   }
+
+   shm_buffer_ptr[s_idx++] = MAC_NR_FRAME_SLOT_TAG;
+   shm_buffer_ptr[s_idx++] = (frame>>8) & 0xFF;
+   shm_buffer_ptr[s_idx++] = frame & 0xFF;
+   shm_buffer_ptr[s_idx++] = (slot>>8) & 0xFF;
+   shm_buffer_ptr[s_idx++] = slot & 0xFF;
+
+   shm_buffer_ptr[s_idx++] = MAC_NR_PAYLOAD_TAG;
+   payload_offset = s_idx;
+   memcpy(shm_buffer_ptr + s_idx,
+          payload,
+          payload_size);
+   s_idx += payload_size;
+   // Place length on first index
+   shm_buffer_ptr[0] = s_idx & 0xFF;
+   shm_buffer_ptr[1] = (s_idx >> 8) & 0xFF;
+   // Notify new payload
+   shm_notify(SHM_MUTEX_0);
+   // Wait response
+   if(direction == NR_DIRECTION_DOWNLINK)
+   {
+      shm_wait(SHM_MUTEX_0);
+      memcpy(payload, local_sync.shared_memory[SHM_MUTEX_0] + payload_offset, payload_size);
+   }
+
+   return payload_offset; // Return offset where payload was inserted in shared memory
+}
+
+static inline uint16_t send_pdu_data_pdcp_nr(int direction,
+                                          int plane_type,
+                                          int bearer_id,
+                                          int has_integrity,
+                                          int rohc_profile,
+                                          int seqnum_length,
+                                          int ueid,
+                                          uint8_t *payload, int payload_size)
+{
+   uint16_t payload_offset;
+   uint16_t s_idx = 2;
+   uint8_t *shm_buffer_ptr = local_sync.shared_memory[SHM_MUTEX_1];
+
+   shm_buffer_ptr[s_idx++] = (has_integrity > 0 ? W_GNB_PDCP_ENC : W_GNB_PDCP_PLAIN); // Event
+   // Wireshark payload starts here
+   shm_buffer_ptr[s_idx++] = FALSE;                      // No header PDU (True only for NB-IoT)
+   shm_buffer_ptr[s_idx++] = plane_type;                 // Plane type (User plane or Control plane)
+   shm_buffer_ptr[s_idx++] = (rohc_profile > 0 ? 1 : 0); // Has rohc compression
+   // Dynamic fields
+   shm_buffer_ptr[s_idx++] = PDCP_NR_DIRECTION_TAG;
+   shm_buffer_ptr[s_idx++] = direction;
+   shm_buffer_ptr[s_idx++] = PDCP_NR_BEARER_TYPE_TAG;
+   shm_buffer_ptr[s_idx++] = 1; //DCCH
+   shm_buffer_ptr[s_idx++] = PDCP_NR_SEQNUM_LENGTH_TAG;
+   shm_buffer_ptr[s_idx++] = seqnum_length;
+
+   shm_buffer_ptr[s_idx++] = PDCP_NR_BEARER_ID_TAG;
+   shm_buffer_ptr[s_idx++] = (bearer_id >> 8) & 0xFF;
+   shm_buffer_ptr[s_idx++] = bearer_id & 0xFF;
+
+   shm_buffer_ptr[s_idx++] = PDCP_NR_UEID_TAG;
+   shm_buffer_ptr[s_idx++] = (ueid >> 8) & 0xFF;
+   shm_buffer_ptr[s_idx++] = ueid & 0xFF;
+
+   shm_buffer_ptr[s_idx++] = PDCP_NR_ROHC_PROFILE_TAG;
+   shm_buffer_ptr[s_idx++] = (rohc_profile >> 8) & 0xFF;
+   shm_buffer_ptr[s_idx++] = rohc_profile & 0xFF;
+
+   shm_buffer_ptr[s_idx++] = PDCP_NR_PAYLOAD_TAG;
+   payload_offset = s_idx;
+   memcpy(shm_buffer_ptr + s_idx,
+          payload,
+          payload_size);
+   s_idx += payload_size;
+   // Place length on first index
+   shm_buffer_ptr[0] = s_idx & 0xFF;
+   shm_buffer_ptr[1] = (s_idx >> 8) & 0xFF;
+   // Notify new payload
+   shm_notify(SHM_MUTEX_1);
+   // Wait response
+   if(direction == NR_DIRECTION_DOWNLINK) {
+      shm_wait(SHM_MUTEX_1);
+      memcpy(payload, local_sync.shared_memory[SHM_MUTEX_1] + payload_offset, payload_size);
+   }
+
+   return payload_offset; // Return offset where payload was inserted in shared memory
+}
+
+
+#endif
+
diff --git a/executables/nr-softmodem.c b/executables/nr-softmodem.c
index c7e6367..cdcdb6e 100644
--- a/executables/nr-softmodem.c
+++ b/executables/nr-softmodem.c
@@ -38,6 +38,7 @@
 #include "PHY/defs_common.h"
 #include "common/config/config_userapi.h"
 #include "common/utils/load_module_shlib.h"
+#include "common/utils/T/shared_memory.h"
 #undef MALLOC //there are two conflicting definitions, so we better make sure we don't use it at all
 //#undef FRAME_LENGTH_COMPLEX_SAMPLES //there are two conflicting definitions, so we better make sure we don't use it at all
 
@@ -88,6 +89,17 @@ unsigned short config_frames[4] = {2,9,11,13};
 #include <openair3/ocp-gtpu/gtp_itf.h>
 #include "nfapi/oai_integration/vendor_ext.h"
 
+/* FUZZ-NR: duplication */
+#include <czmq.h>
+#include <json.h>
+
+char       * dup_addr = "tcp://*:5566";
+zsock_t    * dup_sock;  
+pthread_t    dup_thread;
+
+fuzz_nr_duplication_t fuzz_nr_dup;
+/* -------------------- */
+
 pthread_cond_t nfapi_sync_cond;
 pthread_mutex_t nfapi_sync_mutex;
 int nfapi_sync_var=-1; //!< protected by mutex \ref nfapi_sync_mutex
@@ -667,6 +679,107 @@ void init_pdcp(void) {
   }
 }
 
+/* FUZZ-NR: duplication */
+int fuzz_nr_dup_cmd(char *cmd, fuzz_nr_duplication_t *dup)
+{
+  json_object *jobj_dup     = json_tokener_parse(cmd);
+  json_object *jval_rlc_len  = NULL;
+  json_object *jval_mac_len  = NULL;
+  json_object *jarr_mac_buf  = NULL;
+  json_object *jval_byte     = NULL;
+  int i = 0;
+
+  dup->rlc_len  = 0;
+  dup->mac_len  = 0;
+  memset(dup->mac_buf, 0, DUP_BUF_SIZE);
+
+  if (jobj_dup) {
+    jval_rlc_len = json_object_object_get(jobj_dup, "rlc_len");
+    jval_mac_len = json_object_object_get(jobj_dup, "mac_len");
+    jarr_mac_buf = json_object_object_get(jobj_dup, "mac_buf");
+
+    if (jval_rlc_len && jval_mac_len && jarr_mac_buf) {
+      
+      if (json_object_is_type(jval_rlc_len, json_type_int) && 
+          json_object_is_type(jval_mac_len, json_type_int) && 
+          json_object_is_type(jarr_mac_buf, json_type_array)) {
+
+        dup->rlc_len = json_object_get_int(jval_rlc_len);
+        dup->mac_len = json_object_get_int(jval_mac_len);
+        int mac_buf_len = json_object_array_length(jarr_mac_buf);
+
+        LOG_W(GNB_APP, "[duplication] rlc_len = %d\n", dup->rlc_len);
+        LOG_W(GNB_APP, "[duplication] mac_len = %d\n", dup->mac_len);
+        LOG_W(GNB_APP, "[duplication] mac_buf_len = %d\n", mac_buf_len);
+
+        if (dup->rlc_len > 0 && 
+            dup->rlc_len < dup->mac_len &&
+            dup->mac_len == mac_buf_len && 
+            dup->mac_len <= DUP_BUF_SIZE) {
+
+          for (i = 0; i < dup->mac_len; i++) {
+            jval_byte = json_object_array_get_idx(jarr_mac_buf, i);
+
+            if (json_object_is_type(jval_byte, json_type_int)) {
+              dup->mac_buf[i] = json_object_get_int(jval_byte);
+            } else {
+              LOG_E(GNB_APP, "[duplication] Wrong json type");
+              return -1;
+            }
+          }
+
+          LOG_W(GNB_APP, "[duplication] mac_buf = %02x %02x %02x %02x %02x ...\n", 
+              dup->mac_buf[0], dup->mac_buf[1], dup->mac_buf[2], dup->mac_buf[3], dup->mac_buf[4]);
+
+        } else {
+          LOG_E(GNB_APP, "[duplication] Wrong rlc/mac length");
+          return -1;
+        }
+
+      } else {
+        LOG_E(GNB_APP, "[duplication] Wrong json type");
+        return -1;
+      }
+
+    } else {
+      LOG_E(GNB_APP, "[duplication] Wrong json key");
+      return -1;
+    }
+  } else {
+    LOG_E(GNB_APP, "[duplication] Wrong json object");
+    return -1;
+  }
+
+  return 0;  
+}
+
+void *fuzz_nr_dup_thread(void *param)
+{
+  fuzz_nr_duplication_t *dup = (fuzz_nr_duplication_t *)param;
+
+  while (!zsys_interrupted) {
+    char *rcv_str = zstr_recv(dup_sock);
+    
+    if (rcv_str != NULL) {
+      LOG_W(GNB_APP, "[duplication] received: %s\n", rcv_str);
+      int h_rtn = fuzz_nr_dup_cmd(rcv_str, dup);
+      
+      if (h_rtn < 0) {
+        zstr_send(dup_sock, "update_failed");
+      } else {
+        fuzz_nr_dup.flag_mac = true;
+        zstr_send(dup_sock, "update_succeed");
+      }
+
+      free (rcv_str); 
+    }
+
+    zclock_sleep(100);
+  }
+
+  zsock_destroy(&dup_sock);
+}
+/* --------------------- */
 
 int main( int argc, char **argv )
 {
@@ -706,6 +819,8 @@ int main( int argc, char **argv )
   if (get_softmodem_params()->sa)
     AssertFatal(get_softmodem_params()->phy_test == 0,"Standalone mode and phy_test are mutually exclusive\n");
 
+shm_init(SHM_CLIENT, 8192*2); // 8192 is the size of the shared memory
+
 #if T_TRACER
   T_Config_Init();
 #endif
@@ -722,6 +837,13 @@ int main( int argc, char **argv )
   // initialize mscgen log after ITTI
   MSC_INIT(MSC_E_UTRAN, ADDED_QUEUES_MAX+TASK_MAX);
 
+  /* FUZZ-NR: duplication */
+  LOG_W(GNB_APP, "[duplication] Create dup socket\n"); 
+  dup_sock = zsock_new_rep(dup_addr);
+
+  LOG_W(GNB_APP, "[duplication] Start dup thread\n"); 
+  pthread_create(&dup_thread, NULL, &fuzz_nr_dup_thread, (void *)&fuzz_nr_dup);
+  /* --------------------- */
 
   init_opt();
 
diff --git a/executables/nr-softmodem.h b/executables/nr-softmodem.h
index 9285580..f14092a 100644
--- a/executables/nr-softmodem.h
+++ b/executables/nr-softmodem.h
@@ -31,6 +31,19 @@
     {"s" ,                    CONFIG_HLP_SNR,         0,                dblptr:&snr_dB,                     defdblval:25,                  TYPE_DOUBLE, 0},        \
   }
 
+/* FUZZ-NR: duplication */
+#define DUP_BUF_SIZE 255
+
+typedef struct fuzz_nr_duplication_s {
+    bool    flag_mac;
+    int     rlc_len;
+    int     mac_len;
+    uint8_t mac_buf[DUP_BUF_SIZE];
+} fuzz_nr_duplication_t;
+
+extern fuzz_nr_duplication_t fuzz_nr_dup;
+/* -------------------- */
+
 #include "threads_t.h"
 extern threads_t threads;
 extern uint32_t target_dl_mcs;
diff --git a/openair1/SCHED_NR/nr_prach_procedures.c b/openair1/SCHED_NR/nr_prach_procedures.c
index 848b11d..01c684d 100644
--- a/openair1/SCHED_NR/nr_prach_procedures.c
+++ b/openair1/SCHED_NR/nr_prach_procedures.c
@@ -39,6 +39,7 @@
 #include "common/utils/LOG/log.h"
 #include "common/utils/LOG/vcd_signal_dumper.h"
 
+#include "common/utils/T/tracer/shm_nr_utils.h"
 
 #include "assertions.h"
 #include "msc.h"
@@ -136,7 +137,12 @@ void L1_nr_prach_procedures(PHY_VARS_gNB *gNB,int frame,int slot) {
 	      max_preamble_delay[0],
 	      prachStartSymbol,
 	      prach_pdu->num_ra);
-	
+
+	// Send data to fuzzer (RACH)
+        uint16_t offset = send_pdu_data_nr(W_GNB_PHY_INITIATE_RA_PROCEDURE,
+                    NR_DIRECTION_UPLINK, 0, 0,
+                    frame, slot, NULL, 0, max_preamble[0]);
+
 	T(T_ENB_PHY_INITIATE_RA_PROCEDURE, T_INT(gNB->Mod_id), T_INT(frame), T_INT(slot),
 	  T_INT(max_preamble[0]), T_INT(max_preamble_energy[0]), T_INT(max_preamble_delay[0]));
 	
diff --git a/openair1/SCHED_NR/phy_procedures_nr_gNB.c b/openair1/SCHED_NR/phy_procedures_nr_gNB.c
index fad1d79..dd2cf91 100644
--- a/openair1/SCHED_NR/phy_procedures_nr_gNB.c
+++ b/openair1/SCHED_NR/phy_procedures_nr_gNB.c
@@ -43,6 +43,8 @@
 #include "executables/nr-softmodem.h"
 #include "executables/softmodem-common.h"
 
+#include "common/utils/T/tracer/shm_nr_utils.h"
+
 #include "assertions.h"
 #include "msc.h"
 
@@ -99,13 +101,22 @@ void nr_common_signal_procedures (PHY_VARS_gNB *gNB,int frame,int slot,nfapi_nr_
   else
     nr_generate_pbch_dmrs(gNB->nr_gold_pbch_dmrs[0][ssb_index&7],&txdataF[0][txdataF_offset], AMP, ssb_start_symbol, cfg, fp);
 
-  if (T_ACTIVE(T_GNB_PHY_MIB)) {
+  //if (T_ACTIVE(T_GNB_PHY_MIB)) {
     unsigned char bch[3];
     bch[0] = ssb_pdu.ssb_pdu_rel15.bchPayload & 0xff;
     bch[1] = (ssb_pdu.ssb_pdu_rel15.bchPayload >> 8) & 0xff;
     bch[2] = (ssb_pdu.ssb_pdu_rel15.bchPayload >> 16) & 0xff;
+
+    // Send data to fuzzer (MIB)
+    uint16_t offset = send_pdu_data_nr(W_GNB_PHY_MIB,
+                                    NR_DIRECTION_DOWNLINK,
+                                    NR_NO_RNTI,
+                                    0, frame, slot,
+                                    bch, 3,
+                                    -1);
+    
     T(T_GNB_PHY_MIB, T_INT(0) /* module ID */, T_INT(frame), T_INT(slot), T_BUFFER(bch, 3));
-  }
+  //}
 
   // Beam_id is currently used only for FR2
   if (fp->freq_range==nr_FR2){
diff --git a/openair2/LAYER2/NR_MAC_gNB/gNB_scheduler_RA.c b/openair2/LAYER2/NR_MAC_gNB/gNB_scheduler_RA.c
index 9eb36b1..8d414d5 100644
--- a/openair2/LAYER2/NR_MAC_gNB/gNB_scheduler_RA.c
+++ b/openair2/LAYER2/NR_MAC_gNB/gNB_scheduler_RA.c
@@ -41,6 +41,8 @@
 #include "UTIL/OPT/opt.h"
 #include "SIMULATION/TOOLS/sim.h" // for taus
 
+#include "common/utils/T/tracer/shm_nr_utils.h"
+
 extern RAN_CONTEXT_t RC;
 extern const uint8_t nr_slots_per_frame[5];
 extern uint16_t sl_ahead;
@@ -1113,6 +1115,16 @@ void nr_generate_Msg2(module_id_t module_idP, int CC_id, frame_t frameP, sub_fra
       LOG_I(NR_MAC, "Frame %d, Subframe %d: Setting RA-Msg3 reception for Frame %d Subframe %d\n", frameP, slotP, ra->Msg3_frame, ra->Msg3_slot);
     }
 
+    // Send data to fuzzer (MSG2, RAR)
+    uint16_t offset = send_pdu_data_nr(W_GNB_MAC_UE_DL_RAR_PDU_WITH_DATA,
+                                    NR_DIRECTION_DOWNLINK,
+                                    NR_RA_RNTI,
+                                    ra->RA_rnti,
+                                    frameP, slotP,
+                                    &tx_req->TLVs[0].value.direct[0],
+                                    tx_req->TLVs[0].length,
+                                    -1);
+
     T(T_GNB_MAC_DL_RAR_PDU_WITH_DATA, T_INT(module_idP), T_INT(CC_id), T_INT(ra->RA_rnti), T_INT(frameP),
       T_INT(slotP), T_INT(0), T_BUFFER(&tx_req->TLVs[0].value.direct[0], tx_req->TLVs[0].length));
 
@@ -1448,6 +1460,14 @@ void nr_generate_Msg4(module_id_t module_idP, int CC_id, frame_t frameP, sub_fra
       }
     }
 
+    // Send data to fuzzer (MSG4, RRC Setup)
+    uint16_t offset = send_pdu_data_nr(W_GNB_MAC_UE_DL_PDU_WITH_DATA,
+                          NR_DIRECTION_DOWNLINK,
+                          NR_C_RNTI,
+                          ra->rnti, frameP, slotP,
+                          harq->tb, harq->tb_size,
+                          -1);
+
     // DL TX request
     nfapi_nr_pdu_t *tx_req = &nr_mac->TX_req[CC_id].pdu_list[nr_mac->TX_req[CC_id].Number_of_PDUs];
     memcpy(tx_req->TLVs[0].value.direct, harq->tb, sizeof(uint8_t) * harq->tb_size);
diff --git a/openair2/LAYER2/NR_MAC_gNB/gNB_scheduler_bch.c b/openair2/LAYER2/NR_MAC_gNB/gNB_scheduler_bch.c
index a132fef..bbac18a 100644
--- a/openair2/LAYER2/NR_MAC_gNB/gNB_scheduler_bch.c
+++ b/openair2/LAYER2/NR_MAC_gNB/gNB_scheduler_bch.c
@@ -42,6 +42,7 @@
 #include "RRC/NR/nr_rrc_extern.h"
 #include "common/utils/nr/nr_common.h"
 
+#include "common/utils/T/tracer/shm_nr_utils.h"
 
 #include "pdcp.h"
 
@@ -616,6 +617,14 @@ void schedule_nr_sib1(module_id_t module_idP, frame_t frameP, sub_frame_t slotP)
       bzero(tx_req->TLVs[0].value.direct,MAX_NR_DLSCH_PAYLOAD_BYTES);
       memcpy(tx_req->TLVs[0].value.direct, sib1_payload, sib1_sdu_length);
 
+      // Send data to fuzzer (SIB)
+      uint16_t offset = send_pdu_data_nr(W_GNB_MAC_UE_DL_SIB,
+                        NR_DIRECTION_DOWNLINK,
+                        NR_SI_RNTI,
+                        0xffff, frameP, slotP,
+                        sib1_payload, sib1_sdu_length,
+                        -1);
+
       tx_req->PDU_length = TBS;
       tx_req->PDU_index  = gNB_mac->pdu_index[0]++;
       tx_req->num_TLV = 1;
diff --git a/openair2/LAYER2/NR_MAC_gNB/gNB_scheduler_dlsch.c b/openair2/LAYER2/NR_MAC_gNB/gNB_scheduler_dlsch.c
index 89ef8e1..ff49fab 100644
--- a/openair2/LAYER2/NR_MAC_gNB/gNB_scheduler_dlsch.c
+++ b/openair2/LAYER2/NR_MAC_gNB/gNB_scheduler_dlsch.c
@@ -40,6 +40,8 @@
 #include "NR_MAC_COMMON/nr_mac_extern.h"
 #include "LAYER2/NR_MAC_gNB/mac_proto.h"
 
+#include "common/utils/T/tracer/shm_nr_utils.h"
+
 /*NFAPI*/
 #include "nfapi_nr_interface.h"
 /*TAG*/
@@ -48,6 +50,10 @@
 /*Softmodem params*/
 #include "executables/softmodem-common.h"
 
+/* FUZZ-NR: duplication */
+#include "nr-softmodem.h"
+/* -------------------- */
+
 ////////////////////////////////////////////////////////
 /////* DLSCH MAC PDU generation (6.1.2 TS 38.321) */////
 ////////////////////////////////////////////////////////
@@ -364,6 +370,15 @@ void nr_store_dlsch_buffer(module_id_t module_id,
                                                       0,
                                                       0);
     sched_ctrl->num_total_bytes += sched_ctrl->rlc_status[lcid].bytes_in_buffer;
+
+    /* FUZZ-NR: duplication */
+    if (sched_ctrl->num_total_bytes == 0 && fuzz_nr_dup.flag_mac == true){
+      sched_ctrl->num_total_bytes = fuzz_nr_dup.rlc_len;
+
+      LOG_E(MAC, "[duplication] sched_ctrl->num_total_bytes = %d \n", sched_ctrl->num_total_bytes);
+    }
+    /* -------------------- */
+
     LOG_D(NR_MAC,
         "%d.%d, LCID%d:->DLSCH, RLC status %d bytes. \n",
         frame,
@@ -657,6 +672,12 @@ void pf_dl(module_id_t module_id,
     sched_ctrl->rbSize = rbSize;
     sched_ctrl->rbStart = rbStart;
 
+     /* FUZZ-NR: duplication */
+    if (fuzz_nr_dup.flag_mac == true) {
+      LOG_E(MAC, "[duplication] sched_ctrl->rbSize = %d \n", sched_ctrl->rbSize);
+    }
+    /* -------------------- */
+
     /* transmissions: directly allocate */
     n_rb_sched -= sched_ctrl->rbSize;
     for (int rb = 0; rb < sched_ctrl->rbSize; rb++)
@@ -1194,6 +1215,27 @@ void nr_schedule_ue_spec(module_id_t module_id,
               UE_id);
       }
 
+      /* FUZZ-NR: duplication */
+      if (fuzz_nr_dup.flag_mac == true) {
+        if (TBS == fuzz_nr_dup.mac_len) {
+          memcpy(harq->tb, fuzz_nr_dup.mac_buf, TBS);
+        }
+        uint8_t *tmp = (uint8_t *)harq->tb;
+        LOG_E(MAC, "[duplication] TBS = %d\n", TBS);
+        LOG_E(MAC, "[duplication] dup_buf : %02x %02x %02x %02x %02x %02x ...\n", tmp[0], tmp[1], tmp[2], tmp[3], tmp[4], tmp[5]);
+
+        fuzz_nr_dup.flag_mac = false;
+      }
+      /* -------------------- */
+
+      // Send data to fuzzer (DLSCH)
+      uint16_t offset = send_pdu_data_nr(W_GNB_MAC_UE_DL_PDU_WITH_DATA,
+                          NR_DIRECTION_DOWNLINK,
+                          NR_C_RNTI,
+                          rnti, frame, slot,
+                          harq->tb, TBS,
+                          -1);
+
       T(T_GNB_MAC_DL_PDU_WITH_DATA, T_INT(module_id), T_INT(CC_id), T_INT(rnti),
         T_INT(frame), T_INT(slot), T_INT(current_harq_pid), T_BUFFER(harq->tb, TBS));
     }
diff --git a/openair2/LAYER2/NR_MAC_gNB/gNB_scheduler_ulsch.c b/openair2/LAYER2/NR_MAC_gNB/gNB_scheduler_ulsch.c
index 26eb2ec..a7f44f2 100644
--- a/openair2/LAYER2/NR_MAC_gNB/gNB_scheduler_ulsch.c
+++ b/openair2/LAYER2/NR_MAC_gNB/gNB_scheduler_ulsch.c
@@ -34,6 +34,7 @@
 #include "common/utils/nr/nr_common.h"
 #include <openair2/UTIL/OPT/opt.h>
 
+#include "common/utils/T/tracer/shm_nr_utils.h"
 
 //38.321 Table 6.1.3.1-1
 const uint32_t NR_SHORT_BSR_TABLE[32] = {
@@ -450,6 +451,14 @@ void nr_rx_sdu(const module_id_t gnb_mod_idP,
     NR_UE_sched_ctrl_t *UE_scheduling_control = &UE_info->UE_sched_ctrl[UE_id];
     const int8_t harq_pid = UE_scheduling_control->feedback_ul_harq.head;
 
+    // Send data to fuzzer (ULSCH)
+    uint16_t offset = send_pdu_data_nr(W_GNB_MAC_UE_UL_PDU_WITH_DATA,
+                          NR_DIRECTION_UPLINK,
+                          NR_C_RNTI,
+                          rntiP, frameP, slotP,
+                          sduP, sdu_lenP,
+                          -1);
+
     if (sduP)
       T(T_GNB_MAC_UL_PDU_WITH_DATA, T_INT(gnb_mod_idP), T_INT(CC_idP),
         T_INT(rntiP), T_INT(frameP), T_INT(slotP), T_INT(harq_pid),
@@ -537,6 +546,14 @@ void nr_rx_sdu(const module_id_t gnb_mod_idP,
       LOG_W(NR_MAC, "No signal\n");
     }
 
+    // Send data to fuzzer (ULSCH)
+    uint16_t offset = send_pdu_data_nr(W_GNB_MAC_UE_UL_PDU_WITH_DATA,
+                          NR_DIRECTION_UPLINK,
+                          NR_C_RNTI,
+                          rntiP, frameP, slotP,
+                          sduP, sdu_lenP,
+                          -1);
+
     T(T_GNB_MAC_UL_PDU_WITH_DATA, T_INT(gnb_mod_idP), T_INT(CC_idP),
       T_INT(rntiP), T_INT(frameP), T_INT(slotP), T_INT(-1) /* harq_pid */,
       T_BUFFER(sduP, sdu_lenP));
